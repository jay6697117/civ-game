# civ-game AI 协作开发规则
## LLM Collaboration Protocol v1.0

---

# 一、核心理念

## 1.1 Vibe Development 哲学

> **最珍贵的是对话过程本身，不追求直接出结果，而是步步为营共同规划。**

本项目采用 **Vibe Development** 模式：
- AI 不是执行者，而是协作伙伴
- 不急于产出代码，先对齐理解
- 每个决策都是共同思考的结果
- 对话本身就是设计过程的一部分

## 1.2 决策质量观

> **大量决策，90% 正确率，关键决策零失误**

项目是一系列决策的集合：
- 只有做对 90% 以上的决策，项目才有望成功
- 关键决策容错数: 0
- 因此每个 S/A 级决策都需要 **人机共同 Review**

## 1.3 长期对话工程观

这是一个**长期对话工程**，不是一次性任务：
- 对话是连续的，上下文需要被**持久化保存**
- 每次对话都在前次基础上**迭代推进**
- Git 提交历史记录了**思维演进过程**
- llm.txt 是**活文档**，随项目成长

---

# 二、职能角色定义

本项目模拟多职能协作，AI 在对话中切换不同角色视角：

| 角色代号 | 职能 | 关注点 | 触发词 |
|---------|------|--------|--------|
| `[ARCH]` | 架构 | 底层结构、性能、可扩展性 | "架构"、"底层"、"重构" |
| `[DEV]` | 开发 | 具体实现、Bug修复 | "开发"、"实现"、"代码" |
| `[PM]` | 项目管理 | 里程碑、优先级、进度 | "规划"、"排期"、"优先级" |
| `[QA]` | 产品质量保证 | 验收测试、用户体验验证、边界情况 | "验收"、"体验测试"、"功能验证" |
| `[TEST]` | 单元测试 | 代码测试、覆盖率、自动化测试 | "单元测试"、"测试用例"、"coverage" |
| `[DESIGN]` | 游戏策划 | 玩法、体验、平衡、叙事 | "策划"、"设计"、"玩法" |
| `[ART]` | 美术指导 | 风格、资产规范、视觉反馈 | "美术"、"视觉"、"风格" |

**使用方式**: 在对话中明确指定角色，或让 AI 自动识别并标注当前角色视角。

## 2.2 QA 角色的特殊地位

> **QA 是每个功能的最后守门人，无验收则不算完成**

QA 职能贯穿整个开发流程：
- **开发前**: 参与需求评审，提出测试视角问题
- **开发中**: 准备测试用例框架
- **开发后**: 执行验收测试，确认功能符合预期

---

# 三、决策分级制度

## 3.1 决策等级

| 等级 | 类型 | 影响范围 | Review 要求 |
|-----|------|---------|------------|
| **S** | 战略决策 | 整体方向、核心功能 | 必须人工确认，记录决策理由 |
| **A** | 架构决策 | 系统设计、数据结构 | 人工Review，可异步确认 |
| **B** | 实现决策 | 具体方案选择 | AI 提出建议，人工可快速确认或默认通过 |
| **C** | 细节决策 | 参数、命名、格式 | AI 自主决策，事后可调整 |

## 3.2 决策记录格式

```markdown
## DECISION-{序号}: {标题}
- **等级**: S/A/B/C
- **角色**: [角色代号]
- **问题**: {需要决策的问题}
- **选项**: 
  - A: {选项A}
  - B: {选项B}
- **决策**: {最终选择}
- **理由**: {为什么这么选}
- **日期**: {YYYY-MM-DD}
- **状态**: PENDING / CONFIRMED / REVISED
```

---

# 四、开发流程协议

## 4.1 任务单元定义

开发不按日期，按 **对话任务单元** 推进：

```
任务单元 (Task Unit):
├── ID: TASK-{role}-{seq}
├── role
├── feature
├── dependencies
├── output
├── status
├── dialogue_rounds
└── 状态: TODO / IN_PROGRESS / REVIEW / DONE
```

## 4.2 标准对话流程

### 4.2.0 对话开始时（强制）

> **每次新对话开始，AI 必须先恢复当前状态**

```
1. 读取 docs/CONTEXT.md
2. 读取 llm.txt
3. 了解当前进度
3. 确认用户本次对话目标
```

**项目初始化约束**：
- 如果是新项目且没有 `.git` 目录，必须执行 `git init` 初始化 Git 仓库
- 初始化后立即执行首次提交：`git add -A && git commit -m "init: 项目初始化"`
- Git 是协作记录的基础，没有 Git 无法进行有效的版本追踪

### 4.2.1 对话结束时（强制）

> **每次对话结束前，AI 必须保存当前状态**

```
1. 更新 docs/CONTEXT.md
2. 更新 docs/CHANGELOG.md
3. Git commit → 记录对话成果
```

### 4.2.2 标准对话中流程

```
1. [人] 提出需求/问题
       ↓
2. [AI] 识别角色，分析问题
       ↓
3. [AI] S/A级决策请求确认，B/C级自主执行 ← 条件: decision_level in [S, A]
       ↓
4. [AI] 执行任务，输出结果
       ↓
5. [AI] 更新测试用例（如为功能开发） ← 条件: task_type == feature
       ↓
6. [AI] 总结进展，提示下一步
       ↓
7. [人] 确认/修正/继续
       ↓
8. [AI] Git 提交记录
```

## 4.2.3 需求澄清协议（重要）

> **用户提出需求时可能是自然无意识的，AI 必须将模糊描述转化为结构化需求**

**触发条件**: 用户提出的需求存在以下情况
- 描述模糊或不完整
- 缺少具体的验收标准
- 可能有多种理解方式
- 涉及 S/A 级决策

**澄清流程**:
```
1. [AI] 识别用户意图，提取关键信息
2. [AI] 转化为结构化需求描述
3. [AI] 列出假设和待确认项
4. [人] 确认/修正/补充
5. [AI] 形成最终需求文档
```

**结构化需求模板**:

```markdown
## 需求: {需求标题}

**原始描述**: 
> {用户原话}

**需求分析**:
- 目标: {要达成什么}
- 场景: {在什么情况下使用}
- 用户: {谁会使用}

**功能要求**:
1. {具体功能点1}
2. {具体功能点2}

**验收标准**:
- [ ] {可验证的标准1}
- [ ] {可验证的标准2}

**待确认项**:
- [ ] {需要用户确认的假设1}
- [ ] {需要用户确认的假设2}

**决策等级**: {S/A/B/C}
**预估复杂度**: {高/中/低}
```

**快速澄清问句**:
- "你希望达到什么效果？"
- "有没有参考案例？"
- "这个功能谁会用？在什么场景下用？"
- "如何验证这个功能是否完成？"
- "有时间或资源约束吗？"

**示例**:

用户说: "加个导出功能"

AI 澄清后:
```markdown
## 需求: 数据导出功能

**原始描述**: 
> 加个导出功能

**需求分析**:
- 目标: 将系统数据导出为文件，便于备份或分享
- 场景: 用户需要离线查看或迁移数据时
- 用户: 所有用户

**功能要求**:
1. 支持导出为 JSON 格式
2. 支持导出为 CSV 格式（如有表格数据）
3. 导出文件包含时间戳命名

**验收标准**:
- [ ] 点击导出按钮后生成文件
- [ ] 文件可被其他工具正常打开
- [ ] 导出内容完整无丢失

**待确认项**:
- [ ] 需要导出哪些数据？全部还是部分？
- [ ] 是否需要导出格式选择？
- [ ] 文件大小有限制吗？

**决策等级**: B
**预估复杂度**: 中
```


## 4.3 迭代建议管理协议（重要）

> **QA 测试中产生的迭代建议，必须经过 PM 评审后决定是否纳入当前里程碑**

**迭代建议来源**:
- QA 测试过程中的体验反馈
- 开发过程中发现的改进点
- 用户/人类的直接建议

**PM 评审流程**:
```
1. 收集 → 记录到 docs/ROADMAP.md "迭代建议池"
2. 评审 → 分析优先级、冲突、成本
3. 决策 → 纳入/延后/拒绝
4. 排期 → 确定开发顺序
5. 执行 → 转为 TASK
```

## 4.4 版本回顾协议（重要）

> **每次新版本规划前，必须回顾上个版本的测试表现和用户反馈**

**回顾时机**: 里程碑验收完成后，开始下一阶段规划前

**回顾内容**:
```
1. 测试表现
   - 通过率、问题分布
   - 稳定性评估
   
2. 用户体验反馈
   - 核心功能验证结果
   - 操作体验、视觉体验
   
3. 技术债务
   - 已知问题表
   - 性能瓶颈
   
4. 迭代建议池
   - 上版本积累的建议
   - 优先级重新评估
```

**产出**:
- 补充新的需求到下一阶段
- 调整任务优先级
- 记录设计决策

## 4.5 构建打包协议（重要）

> **全量验收前必须完成打包流程，打包是开发的一环**

**构建时机**:
- ✅ 里程碑全量验收前
- ✅ Bug 修复期集中测试
- ✅ 准备分发/演示版本
- ❌ 不需要每次提交都构建

**全量验收前 CheckList**:
```
[ ] 1. npm run build
[ ] 2. 双击 dist/index.html 测试
[ ] 3. 确认正常运行
[ ] 4. 更新操作说明（如有新功能）
```

## 4.6 配置级迭代协议（重要）

> **仅修改数值配置、不改动代码逻辑的迭代，可快速执行**

**定义**: 配置级迭代 = 仅调整现有参数值，不增删代码逻辑

**可快速执行的配置示例**:
- 数值参数调整
- 配置文件修改
- 样式/主题变更
- 文案/文本修改

**执行规则**:
1. 用户明确指出"配置调整"或"数值修改"
2. AI 直接修改对应配置值
3. 无需 PM 审批，无需创建 TASK
4. commit 使用 `[CONFIG]` 前缀

**不适用情况** (需 PM 审核排期):
- 需要新增函数/类/文件
- 涉及系统交互逻辑变更
- 可能影响其他模块
- 用户不确定该改什么


## 4.7 QA 验收协议（重要）

> **每个功能完成后，必须同步更新 QA 测试用例，供验收使用**

**QA 测试用例要素**:
- 测试 ID (TC-{module}-{seq})
- 关联功能 (TASK-ID)
- 前置条件
- 测试步骤 (可复现的操作序列)
- 预期结果 (明确、可验证)
- 测试状态

**开发者责任**:
1. 功能完成时，在 `docs/QA_TEST_CASES.md` 添加测试用例
2. 提供清晰的操作步骤和预期表现
3. 标注已知限制或边界情况

**QA 责任**:
1. 按测试用例执行验收测试
2. 记录实际结果和问题
3. 更新测试状态 (通过/部分通过/未通过)
4. **验收失败时**: 附上日志/截图
5. 提交 Bug 到已知问题表

## 4.8 快速验收回复模板

功能开发完成后，AI 必须提供**快速验收清单**，用户可直接复制回复：

```markdown
## 🧪 快速验收

**启动**: `npm run dev`

**验收项**:
- [ ] 功能A: {操作} → {预期}
- [ ] 功能B: {操作} → {预期}
- [ ] 功能C: {操作} → {预期}

**快速回复** (复制修改后发送):
✅ 全部通过
或
⚠️ 问题: {描述问题}
```

**用户回复格式**:
- `✅` 或 `通过` - 全部验收通过，继续下一步
- `⚠️ 问题: xxx` - 有问题需要修复
- `跳过` - 暂不验收，先继续


## 4.3 Git 协作规范

### 分支策略
```
main                 # 稳定版本
├── dev              # 开发主线
│   ├── feature/{特性名}     # 功能开发
│   ├── design/{设计文档}    # 设计迭代
│   ├── refactor/{模块名}    # 重构优化
│   └── fix/{问题描述}       # Bug修复
```

### Commit 前缀
```
[DESIGN]  设计文档变更
[ARCH]  架构调整
[FEAT]  新功能
[FIX]  Bug修复
[CONFIG]  配置调整（不改逻辑）
[REFACTOR]  重构
[DOC]  文档更新
[TEST]  测试相关
[VIBE]  协作流程更新
```

### Git 提交要求（重要）

> **每次有效对话都必须产生 Git 提交，记录思维演进**

Git 历史不仅是代码版本，更是**设计思维的演进记录**。

---

# 五、测试体系

## 5.1 单元测试 (Unit Test)

> **开发者视角：验证代码逻辑正确性**

| 配置项 | 值 |
|-------|-----|
| 测试框架 | jest |
| 覆盖率目标 | 80% |
| 文件模式 | **/*.test.ts, **/*.spec.ts |
| 运行时机 | pre-commit, ci |

**单元测试原则**:
- 每个模块应有对应的测试文件
- 关键函数必须有测试覆盖
- 测试应该独立、可重复
- Mock 外部依赖

## 5.2 产品QA验收 (Product QA)

> **用户视角：验证功能符合预期**

**测试用例文件**: `docs/QA_TEST_CASES.md`

**用例ID格式**: `TC-{module}-{seq}`

**测试用例要素**:
- id
- feature
- precondition
- steps
- expected
- status

**测试状态**:
- 🟢 PASS
- 🟡 PARTIAL
- 🔴 FAIL
- ⚪ SKIP

## 5.3 Unit Test vs Product QA 区别

| 维度 | Unit Test | Product QA |
|------|-----------|------------|
| 视角 | 开发者 | 用户 |
| 目标 | 代码正确性 | 功能完整性 |
| 粒度 | 函数/模块级 | 功能/流程级 |
| 执行 | 自动化 | 可自动+人工 |
| 时机 | 提交时 | 功能完成时 |
| 工具 | 测试框架 | 测试用例手册 |

---

# 六、里程碑定义

## 6.1 里程碑规范

> **里程碑 = 多个特性 + Bug修复期 + 全量验收**

### 里程碑生命周期

```
┌─────────────────────────────────────────────────────────┐
│                   里程碑生命周期                          │
├─────────────────────────────────────────────────────────┤
│  1. feature_dev - 特性开发期
│     └── 所有计划特性完成
│     └── 快速验收通过
├─────────────────────────────────────────────────────────┤
│  2. feature_freeze - 特性冻结
│     └── 不再添加新功能
│     └── 构建成功
├─────────────────────────────────────────────────────────┤
│  3. bug_fix - Bug 修复期
│     └── P0/P1 问题清零
│     └── 测试通过率达标
├─────────────────────────────────────────────────────────┤
│  4. acceptance - 里程碑验收
│     └── QA 全量测试通过
│     └── 单元测试覆盖率达标
│     └── 已知问题清零或标记延后
├─────────────────────────────────────────────────────────┤
│  5. retrospective - 版本回顾
│     └── 回顾测试表现
│     └── 收集用户反馈
│     └── 补充新需求到下一阶段
└─────────────────────────────────────────────────────────┘
```

### Bug 优先级

| 优先级 | 描述 |
|-------|------|
| P0 | 崩溃/阻断 |
| P1 | 功能异常 |
| P2 | 体验问题 |
| P3 | 优化建议 |

### 里程碑 Tag

```bash
git tag -a v{major}.{minor}.{patch} -m "描述"
```

---

# 七、迭代管理

## 7.1 迭代建议管理协议

> **迭代建议必须经过 PM 评审后决定是否纳入当前里程碑**

**决策分类**:
- ✅ 纳入当前里程碑
- ⏳ 延后到下个里程碑
- ❌ 拒绝（不符合方向）
- 🔄 合并其他迭代

**评审维度**:
- 与当前任务的依赖/冲突关系
- 对用户体验的影响程度
- 开发成本和技术复杂度
- 里程碑剩余时间约束

## 7.2 配置级迭代协议

> **仅修改配置、不改动代码逻辑的迭代，可快速执行**

**执行规则**:
- 用户明确指出"配置调整"
- AI 直接修改对应配置值
- 无需 PM 审批，无需创建 TASK
- commit 使用 `[CONFIG]` 前缀

**适用示例**:
- 数值参数调整
- 配置文件修改
- 样式/主题变更
- 文案/文本修改

---

# 八、上下文管理

## 8.1 关键文件职责

| 文件 | 职责 | 更新时机 |
|-----|------|---------|
| `llm.txt` | AI 协作规则，顶层指导 | 协作方式演进时 |
| `docs/CONTEXT.md` | 当前开发上下文 | 每次对话结束时 |
| `docs/DECISIONS.md` | 重要决策记录 | 每次 S/A 级决策后 |
| `docs/CHANGELOG.md` | 版本变更日志 | 每次有效对话后 |
| `docs/QA_TEST_CASES.md` | 产品QA测试用例 | 每个功能完成时 |
| `docs/ROADMAP.md` | 路线图+迭代建议 | 里程碑规划/反馈时 |

## 8.2 上下文恢复协议

当开启新对话时，AI 应：
1. 读取 `llm.txt` 了解协作规则
2. 读取 `docs/CONTEXT.md` 恢复当前状态
3. 读取 `docs/DECISIONS.md` 了解已确认和待定决策
4. 运行 `git log --oneline -10` 了解最近进展
5. 询问用户本次对话目标

## 8.3 上下文保存协议

每次对话结束时，AI 应：
1. 更新 `docs/CONTEXT.md` 保存当前状态
2. 更新 `docs/CHANGELOG.md` 记录本次产出
3. 如有新决策，更新 `docs/DECISIONS.md`
4. **必须执行 git commit** 记录本次对话产出

---

# Prompt 工程最佳实践

## 有效提问模板

### 架构讨论
```
[ARCH] 我需要设计{模块名}的架构
需求: {功能需求}
约束: {性能/兼容性约束}
请给出2-3个方案对比

```

### 开发讨论
```
[DEV] 请实现{功能}
输入: {输入描述}
输出: {期望输出}
相关文件: {文件路径}

```

### 项目管理讨论
```
[PM] 请帮我{任务描述}
```

### 产品质量保证讨论
```
[QA] 请帮我{任务描述}
```

### 问题诊断
```
[QA] 遇到问题: {问题描述}
复现步骤: {步骤}
期望行为: {期望}
实际行为: {实际}
```

## 高价值引导词

| 场景 | 引导词 |
|-----|-------|
| 深入分析 | "请从{角色}视角分析"、"有哪些我没考虑到的" |
| 方案对比 | "给出2-3个方案并对比优劣" |
| 风险评估 | "这个方案最大的风险是什么" |
| 简化问题 | "MVP版本最少需要什么" |
| 扩展思考 | "如果未来要支持{X}，现在要预留什么" |
| Vibe 对齐 | "你理解我的意图了吗"、"我们先对齐一下理解" |

## Vibe Development 沟通技巧

### 不要说
- "帮我写一个XXX" (太直接，跳过思考)
- "直接给我代码" (跳过设计讨论)

### 推荐说
- "我想和你讨论一下XXX的设计"
- "你觉得这个方案有什么问题"
- "我们先对齐一下理解，再动手"
- "这个决策你怎么看"
- "把你的思考过程告诉我"

---

# 九、符号学标注系统

本协议使用统一的符号体系确保沟通一致性：

## Decision Status

| 符号 | 含义 |
|------|------|
| `PENDING` | 待确认 |
| `CONFIRMED` | 已确认 |
| `REVISED` | 已修订 |

## Task Status

| 符号 | 含义 |
|------|------|
| `TODO` | 待开始 |
| `IN_PROGRESS` | 进行中 |
| `REVIEW` | 待审核 |
| `DONE` | 已完成 |

## Test Status

| 符号 | 含义 |
|------|------|
| `🟢` | 通过 |
| `🟡` | 部分通过 |
| `🔴` | 未通过 |
| `⚪` | 跳过 |

## Priority

| 符号 | 含义 |
|------|------|
| `P0` | 最高优先级/阻断 |
| `P1` | 高优先级 |
| `P2` | 中优先级 |
| `P3` | 低优先级 |

---

# 已确认决策汇总

*暂无已确认决策，将在项目进行中记录*

---

# 附录：领域扩展

## GAME 领域扩展

### 流程钩子

以下钩子在特定流程节点自动触发：

| 触发点 | 动作 | 条件 | 说明 |
|-------|------|------|------|
| `qa.list_test_cases` | inject_context | `files.exists('docs/GM_COMMANDS.md')` | GM 控制台命令，用于快速测试 |
| `dev.feature_complete` | inject_context | `project.has_feature('gm_console')` | None |
| `build.pre` | append_checklist | - | None |
| `dialogue.start` | require_file_read | `topic.relates_to('design')` | 游戏设计文档 |

### 可注入上下文

**gm_commands** (reference)
: GM 控制台命令，用于快速测试
- 来源: `docs/GM_COMMANDS.md`

**gm_test_guide** (template)

**build_checklist** (template)

**gdd_files** (file_list)
: 游戏设计文档
- 匹配: `docs/GDD_*.md`

### 领域文件

| 文件 | 用途 |
|------|------|
| `docs/GM_COMMANDS.md` | GM 控制台命令文档 |
| `docs/BALANCE.md` | 数值平衡表 |

---


# 十、快速参考

## 开始新对话时说

```
继续项目开发。
请先读取 llm.txt 和 docs/CONTEXT.md 恢复上下文。
本次对话目标: {你的目标}
```

## 结束对话前说

```
请更新 docs/CONTEXT.md 保存当前进度。
总结本次对话的决策和产出。
然后 git commit 记录本次对话。
```

## Vibe Check

```
在继续之前，确认一下：
- 我们对齐理解了吗？
- 这个方向对吗？
- 有什么我没考虑到的？
```

---

# 本文档迭代日志

| 版本 | 日期 | 变更内容 |
|-----|------|---------|
| v1.0 | 2026-01-21 | 初始版本 |

---

# Git 提交历史参考

本项目的 Git 历史记录了完整的设计演进过程：

```bash
# 查看提交历史
git log --oneline

# 查看某次提交详情
git show <commit-hash>

# 查看文件变更历史
git log --follow -p <file>
```

---


*本文档是活文档，记录人机协作的演进过程。*
*生成时间: 2026-01-21 02:33:56*
*最珍贵的不是结果，而是我们共同思考的旅程。*
